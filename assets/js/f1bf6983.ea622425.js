"use strict";(globalThis.webpackChunkbook=globalThis.webpackChunkbook||[]).push([[651],{2182:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"part-2-ros2/ros2-fundamentals","title":"ROS 2 Fundamentals","description":"Learning Objectives","source":"@site/docs/part-2-ros2/02-ros2-fundamentals.md","sourceDirName":"part-2-ros2","slug":"/part-2-ros2/ros2-fundamentals","permalink":"/Ary-s-Physical-Humanoid-Robotics/docs/part-2-ros2/ros2-fundamentals","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/part-2-ros2/02-ros2-fundamentals.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"ROS 2 Fundamentals","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Week 1-2 Overview: Physical AI Foundations","permalink":"/Ary-s-Physical-Humanoid-Robotics/docs/part-1-foundations/01a-week-1-2-overview"},"next":{"title":"Weeks 3-5 Overview: ROS 2 Fundamentals","permalink":"/Ary-s-Physical-Humanoid-Robotics/docs/part-2-ros2/02a-week-3-5-overview"}}');var s=t(4848),r=t(8453);const o={title:"ROS 2 Fundamentals",sidebar_position:2},a="Chapter 2: ROS 2 Fundamentals",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"2.1 Introduction to ROS 2",id:"21-introduction-to-ros-2",level:2},{value:"The Evolution from ROS 1 to ROS 2",id:"the-evolution-from-ros-1-to-ros-2",level:3},{value:"ROS 2 Architecture Overview",id:"ros-2-architecture-overview",level:3},{value:"Key Concepts in ROS 2",id:"key-concepts-in-ros-2",level:3},{value:"DDS and Quality of Service",id:"dds-and-quality-of-service",level:3},{value:"2.2 Nodes, Topics, Services, and Actions",id:"22-nodes-topics-services-and-actions",level:2},{value:"ROS 2 Nodes",id:"ros-2-nodes",level:3},{value:"Topics: Publisher-Subscriber Communication",id:"topics-publisher-subscriber-communication",level:3},{value:"Services: Request-Reply Communication",id:"services-request-reply-communication",level:3},{value:"Actions: Long-Running Tasks",id:"actions-long-running-tasks",level:3},{value:"2.3 Building ROS 2 Packages with Python",id:"23-building-ros-2-packages-with-python",level:2},{value:"Package Structure",id:"package-structure",level:3},{value:"Package Configuration Files",id:"package-configuration-files",level:3},{value:"Entry Point Scripts",id:"entry-point-scripts",level:3},{value:"2.4 Launch Files and Parameter Management",id:"24-launch-files-and-parameter-management",level:2},{value:"Python Launch Files",id:"python-launch-files",level:3},{value:"Parameter Management with YAML",id:"parameter-management-with-yaml",level:3},{value:"2.5 Complete Publisher-Subscriber Example",id:"25-complete-publisher-subscriber-example",level:2},{value:"Hardware Requirements Reference",id:"hardware-requirements-reference",level:3},{value:"Chapter Summary",id:"chapter-summary",level:2},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Key Terminology",id:"key-terminology",level:3},{value:"Further Reading",id:"further-reading",level:3},{value:"Next Chapter",id:"next-chapter",level:3},{value:"Transition to Simulation",id:"transition-to-simulation",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"chapter-2-ros-2-fundamentals",children:"Chapter 2: ROS 2 Fundamentals"})}),"\n",(0,s.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Understand the ROS 2 architecture and its communication paradigms"}),"\n",(0,s.jsx)(n.li,{children:"Implement ROS 2 nodes, publishers, subscribers, services, and actions using Python (rclpy)"}),"\n",(0,s.jsx)(n.li,{children:"Create and configure ROS 2 packages for humanoid robot applications"}),"\n",(0,s.jsx)(n.li,{children:"Design launch files and manage parameters for robot systems"}),"\n",(0,s.jsx)(n.li,{children:"Apply best practices for building robust ROS 2-based humanoid robot software"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"21-introduction-to-ros-2",children:"2.1 Introduction to ROS 2"}),"\n",(0,s.jsx)(n.p,{children:"The Robot Operating System 2 (ROS 2) is the second generation of ROS, redesigned from the ground up to meet the demands of production robotics systems. While ROS 1 revolutionized robotics research by providing a common framework for robot software development, ROS 2 addresses critical limitations including real-time requirements, safety certifications, and production deployment."}),"\n",(0,s.jsx)(n.h3,{id:"the-evolution-from-ros-1-to-ros-2",children:"The Evolution from ROS 1 to ROS 2"}),"\n",(0,s.jsx)(n.p,{children:"ROS 1 emerged from the Stanford AI Lab and Willow Garage in the late 2000s, becoming the de facto standard for robotics research worldwide. However, as robots moved from laboratory environments into real-world applications, several limitations became apparent:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Aspect"}),(0,s.jsx)(n.th,{children:"ROS 1"}),(0,s.jsx)(n.th,{children:"ROS 2"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Real-time Support"}),(0,s.jsx)(n.td,{children:"Limited (via Orocos RTE)"}),(0,s.jsx)(n.td,{children:"Native real-time support"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Security"}),(0,s.jsx)(n.td,{children:"No built-in security"}),(0,s.jsx)(n.td,{children:"DDS security framework"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Lifecycle Management"}),(0,s.jsx)(n.td,{children:"Custom scripts"}),(0,s.jsx)(n.td,{children:"Managed node lifecycle"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Communication Reliability"}),(0,s.jsx)(n.td,{children:"Best-effort"}),(0,s.jsx)(n.td,{children:"Configurable QoS policies"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Multi-robot Support"}),(0,s.jsx)(n.td,{children:"Complex setup"}),(0,s.jsx)(n.td,{children:"Native support"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Deployment"}),(0,s.jsx)(n.td,{children:"Research-focused"}),(0,s.jsx)(n.td,{children:"Production-ready"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"ROS 2 adopts the Data Distribution Service (DDS) as its underlying communication middleware, providing industry-grade reliability and real-time performance. DDS is used in aerospace, defense, and autonomous vehicle systems where reliability is paramount."}),"\n",(0,s.jsx)(n.h3,{id:"ros-2-architecture-overview",children:"ROS 2 Architecture Overview"}),"\n",(0,s.jsx)(n.p,{children:"The ROS 2 architecture consists of multiple layers, each building upon the foundations below:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Application Layer                        \u2502\n\u2502         (Robot-specific nodes and algorithms)                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                      ROS 2 Client Library                    \u2502\n\u2502           (rclpy, rclcpp, rcljava, rclnodejs)               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                     ROS 2 Middleware                         \u2502\n\u2502              (DDS implementation - rmw layer)               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                   DDS Vendor Implementation                  \u2502\n\u2502        (Fast-DDS, CycloneDDS, RTI Connext, etc.)            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                     Transport Layer                          \u2502\n\u2502                    (UDP, TCP, shared memory)                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(n.p,{children:"The ROS 2 middleware interface (RMW) abstracts DDS implementations, allowing users to choose between different vendors without changing their application code. For humanoid robotics development, Fast-DDS is commonly used due to its open-source license and good performance characteristics."}),"\n",(0,s.jsx)(n.h3,{id:"key-concepts-in-ros-2",children:"Key Concepts in ROS 2"}),"\n",(0,s.jsx)(n.p,{children:"ROS 2 introduces several fundamental concepts that form the building blocks of any robot application:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Workspaces"}),": A workspace is a directory containing ROS 2 packages, where you build and install your software. The typical structure includes a ",(0,s.jsx)(n.code,{children:"src"})," directory for source code, ",(0,s.jsx)(n.code,{children:"install"})," for built artifacts, and ",(0,s.jsx)(n.code,{children:"log"})," for build and runtime logs."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Packages"}),": The fundamental unit of ROS 2 software organization. A package contains everything needed for a specific robot functionality: source code, configuration files, launch files, and metadata. Packages can contain nodes, libraries, tools, and documentation."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Build System"}),": ROS 2 uses ament as its build system, typically invoked through colcon build tools. The build system handles dependency resolution, compilation, and installation of packages."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Distribution"}),": A distribution is a versioned set of ROS 2 packages that are tested together. Current LTS distributions include Humble Hawksbill (Ubuntu 22.04) and Iron Irwini (Ubuntu 23.10). For humanoid robotics, Humble is recommended due to its long-term support and extensive documentation."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Setting up a ROS 2 workspace\nsource /opt/ros/humble/setup.bash\nmkdir -p ~/humanoid_ws/src\ncd ~/humanoid_ws\ncolcon build\nsource install/setup.bash\n"})}),"\n",(0,s.jsx)(n.h3,{id:"dds-and-quality-of-service",children:"DDS and Quality of Service"}),"\n",(0,s.jsx)(n.p,{children:"One of the most powerful features of ROS 2 is its Quality of Service (QoS) policies, inherited from DDS. QoS policies allow developers to tune communication behavior for different use cases:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Policy"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"Use Case"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Reliability"}),(0,s.jsx)(n.td,{children:"Reliable (retransmits) vs. Best Effort"}),(0,s.jsx)(n.td,{children:"Best effort for sensor streams"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Durability"}),(0,s.jsx)(n.td,{children:"Persistent data for late joiners"}),(0,s.jsx)(n.td,{children:"Configuration sharing"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Deadline"}),(0,s.jsx)(n.td,{children:"Expected publication rate"}),(0,s.jsx)(n.td,{children:"Real-time guarantees"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Liveliness"}),(0,s.jsx)(n.td,{children:"Automated node health checking"}),(0,s.jsx)(n.td,{children:"Safety-critical systems"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"History"}),(0,s.jsx)(n.td,{children:"Keep last N samples"}),(0,s.jsx)(n.td,{children:"Sensor data buffering"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"For humanoid robot sensor streams, a typical configuration uses:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sensors"}),": Best effort reliability, keep last sample, deadline matching sample rate"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Control Commands"}),": Reliable delivery, keep last sample, low latency"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"State Estimation"}),": Reliable, durability with transient-local, history depth of 10"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"22-nodes-topics-services-and-actions",children:"2.2 Nodes, Topics, Services, and Actions"}),"\n",(0,s.jsx)(n.p,{children:"ROS 2 provides four primary communication mechanisms, each suited to different patterns of interaction between robot components."}),"\n",(0,s.jsx)(n.h3,{id:"ros-2-nodes",children:"ROS 2 Nodes"}),"\n",(0,s.jsx)(n.p,{children:"A ROS 2 node is a single-purpose executable that performs a specific task. In humanoid robotics, you might have separate nodes for:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"IMU data acquisition and filtering"}),"\n",(0,s.jsx)(n.li,{children:"Camera image processing"}),"\n",(0,s.jsx)(n.li,{children:"Joint trajectory generation"}),"\n",(0,s.jsx)(n.li,{children:"Balance control"}),"\n",(0,s.jsx)(n.li,{children:"Path planning"}),"\n",(0,s.jsx)(n.li,{children:"Speech synthesis"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Nodes should be designed as single-responsibility components that communicate with other nodes through well-defined interfaces. This modular architecture enables independent development, testing, and replacement of system components."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nBasic ROS 2 Node Structure\n\nThis example demonstrates the fundamental structure of a ROS 2 node\nusing rclpy, the Python client library for ROS 2.\n"""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\nfrom sensor_msgs.msg import Imu\nfrom geometry_msgs.msg import WrenchStamped\n\n\nclass HumanoidNode(Node):\n    """\n    Base class for humanoid robot nodes.\n\n    This node demonstrates proper initialization, shutdown handling,\n    and lifecycle management for ROS 2 nodes.\n    """\n\n    def __init__(self, node_name: str, namespace: str = None):\n        """\n        Initialize the humanoid robot node.\n\n        Args:\n            node_name: Unique identifier for this node\n            namespace: Optional namespace for topic scoping\n        """\n        # Initialize the node with a timer for periodic operations\n        super().__init__(node_name, namespace=namespace)\n\n        # Create a timer for the main control loop\n        self.timer_period = 0.01  # 100 Hz control rate\n        self.timer = self.create_timer(self.timer_period, self.control_loop)\n\n        # Track node state\n        self.is_initialized = False\n        self._initialize_state()\n\n        self.get_logger().info(f"Node \'{self.get_name()}\' initialized")\n\n    def _initialize_state(self):\n        """Initialize internal state variables."""\n        self.current_state = "idle"\n        self.last_update_time = self.get_clock().now()\n        self.cycle_count = 0\n\n    def control_loop(self):\n        """\n        Main control loop executed at the timer rate.\n\n        This method should be overridden by subclasses to implement\n        specific node functionality.\n        """\n        self.cycle_count += 1\n        # Placeholder for actual control logic\n        pass\n\n    def cleanup(self):\n        """\n        Cleanup resources before node shutdown.\n\n        Override this method to release allocated resources,\n        save state, or perform final operations.\n        """\n        self.get_logger().info(f"Shutting down node \'{self.get_name()}\'")\n        self.is_initialized = False\n\n\ndef main(args=None):\n    """Entry point for the ROS 2 node."""\n    rclpy.init(args=args)\n\n    try:\n        node = HumanoidNode("humanoid_base_node")\n\n        # Spin the node to process callbacks\n        rclpy.spin(node)\n\n    except KeyboardInterrupt:\n        pass\n    finally:\n        # Cleanup and shutdown\n        if \'node\' in locals():\n            node.cleanup()\n        rclpy.shutdown()\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,s.jsx)(n.h3,{id:"topics-publisher-subscriber-communication",children:"Topics: Publisher-Subscriber Communication"}),"\n",(0,s.jsx)(n.p,{children:"Topics implement a publish-subscribe communication pattern where publishers send messages without knowing who receives them, and subscribers receive messages without knowing who sent them. This decoupled architecture is ideal for sensor data streaming and broadcast communications."}),"\n",(0,s.jsx)(n.p,{children:"For humanoid robots, typical topic-based communications include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sensor Streams"}),": IMU data, camera images, LIDAR scans published at high frequency"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"System State"}),": Joint positions, velocities, efforts published for monitoring"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Command Broadcasts"}),": Trajectory commands, mode switches, emergency stops"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nIMU Publisher Node\n\nThis node demonstrates publisher-subscriber patterns for streaming\nsensor data in a humanoid robot system.\n"""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Imu\nfrom geometry_msgs.msg import Vector3, Quaternion\nfrom std_msgs.msg import Header\nimport numpy as np\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n\n@dataclass\nclass IMUCalibration:\n    """Calibration parameters for an IMU sensor."""\n    accel_scale: np.ndarray = None\n    accel_offset: np.ndarray = None\n    gyro_scale: np.ndarray = None\n    gyro_offset: np.ndarray = None\n\n    def __post_init__(self):\n        if self.accel_scale is None:\n            self.accel_scale = np.eye(3)\n        if self.gyro_scale is None:\n            self.gyro_scale = np.eye(3)\n\n\nclass IMUPublisherNode(Node):\n    """\n    Node for publishing IMU data from a humanoid robot sensor.\n\n    This node:\n    - Interfaces with IMU hardware (simulated in this example)\n    - Applies calibration corrections\n    - Publishes calibrated IMU data on a topic\n\n    Topics:\n        ~/imu_raw: Raw IMU data (calibration input)\n        ~/imu: Calibrated IMU data (published)\n    """\n\n    def __init__(self):\n        super().__init__(\'imu_publisher_node\')\n\n        # Declare parameters with defaults\n        self.declare_parameter(\'sensor_frame_id\', \'imu_link\')\n        self.declare_parameter(\'publish_rate\', 200.0)  # Hz\n        self.declare_parameter(\'use_calibration\', True)\n        self.declare_parameter(\'calibration_file\', \'\')\n\n        # Get parameter values\n        self.frame_id = self.get_parameter(\'sensor_frame_id\').value\n        self.publish_rate = self.get_parameter(\'publish_rate\').value\n        self.use_calibration = self.get_parameter(\'use_calibration\').value\n\n        # Initialize calibration\n        self.calibration = IMUCalibration()\n\n        # Create publishers\n        self.imu_pub = self.create_publisher(\n            Imu,\n            \'~/imu\',\n            10  # QoS depth for sensor data\n        )\n\n        # Create timer for periodic publishing\n        timer_period = 1.0 / self.publish_rate\n        self.timer = self.create_timer(timer_period, self.publish_imu_data)\n\n        # Simulated sensor state\n        self._sim_time = 0.0\n\n        self.get_logger().info(f"IMU Publisher initialized at {self.publish_rate} Hz")\n\n    def _apply_calibration(self, raw_accel: np.ndarray,\n                           raw_gyro: np.ndarray) -> tuple:\n        """\n        Apply calibration corrections to raw sensor readings.\n\n        Args:\n            raw_accel: Raw accelerometer reading [ax, ay, az]\n            raw_gyro: Raw gyroscope reading [gx, gy, gz]\n\n        Returns:\n            Tuple of (corrected_accel, corrected_gyro)\n        """\n        if not self.use_calibration:\n            return raw_accel, raw_gyro\n\n        # Apply scale and offset corrections\n        corrected_accel = self.calibration.accel_scale @ (raw_accel - self.calibration.accel_offset)\n        corrected_gyro = self.calibration.gyro_scale @ (raw_gyro - self.calibration.gyro_offset)\n\n        return corrected_accel, corrected_gyro\n\n    def _simulate_imu_reading(self) -> tuple:\n        """\n        Simulate IMU reading for demonstration.\n\n        In a real implementation, this would read from actual hardware.\n        """\n        self._sim_time += 1.0 / self.publish_rate\n\n        # Simulate static acceleration + gravity + small noise\n        gravity = np.array([0.0, 0.0, 9.81])\n        noise_level = 0.01\n        accel = gravity + np.random.randn(3) * noise_level\n\n        # Simulate angular velocity (slight tilt oscillation)\n        omega = 0.1 * np.sin(self._sim_time * 0.5)\n        gyro = np.array([omega, omega * 0.5, 0.0]) + np.random.randn(3) * 0.001\n\n        return accel, gyro\n\n    def publish_imu_data(self):\n        """Read and publish calibrated IMU data."""\n        # Get raw reading from hardware\n        raw_accel, raw_gyro = self._simulate_imu_reading()\n\n        # Apply calibration\n        accel, gyro = self._apply_calibration(raw_accel, raw_gyro)\n\n        # Create IMU message\n        msg = Imu()\n\n        # Set header\n        msg.header = Header()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = self.frame_id\n\n        # Set orientation (would come from sensor fusion in real system)\n        msg.orientation = Quaternion(w=1.0, x=0.0, y=0.0, z=0.0)\n        msg.orientation_covariance = [1e-6, 0.0, 0.0, 0.0, 1e-6, 0.0, 0.0, 0.0, 1e-6]\n\n        # Set linear acceleration\n        msg.linear_acceleration = Vector3(x=accel[0], y=accel[1], z=accel[2])\n        msg.linear_acceleration_covariance = [0.01, 0.0, 0.0, 0.0, 0.01, 0.0, 0.0, 0.0, 0.01]\n\n        # Set angular velocity\n        msg.angular_velocity = Vector3(x=gyro[0], y=gyro[1], z=gyro[2])\n        msg.angular_velocity_covariance = [1e-5, 0.0, 0.0, 0.0, 1e-5, 0.0, 0.0, 0.0, 1e-5]\n\n        # Publish with QoS for sensors (best effort)\n        self.imu_pub.publish(msg)\n\n\nclass IMUSubscriberNode(Node):\n    """\n    Node for subscribing to and processing IMU data.\n\n    This node demonstrates the subscriber side of the publish-subscribe\n    pattern, including message filtering and processing.\n    """\n\n    def __init__(self, imu_topic: str = \'~/imu\'):\n        super().__init__(\'imu_subscriber_node\')\n\n        # Create subscription with callback\n        self.subscription = self.create_subscription(\n            Imu,\n            imu_topic,\n            self.imu_callback,\n            10  # QoS depth\n        )\n\n        # Maintain message history for processing\n        self.latest_imu: Optional[Imu] = None\n        self.imu_history = []\n        self.max_history = 100\n\n        # Moving average filters\n        self.accel_filtered = np.zeros(3)\n        self.gyro_filtered = np.zeros(3)\n        self.alpha = 0.1  # Smoothing factor\n\n        self.get_logger().info(f"Subscribed to {imu_topic}")\n\n    def imu_callback(self, msg: Imu):\n        """\n        Process incoming IMU messages.\n\n        Args:\n            msg: Incoming IMU message\n        """\n        self.latest_imu = msg\n\n        # Apply low-pass filtering\n        accel = np.array([msg.linear_acceleration.x,\n                          msg.linear_acceleration.y,\n                          msg.linear_acceleration.z])\n        gyro = np.array([msg.angular_velocity.x,\n                         msg.angular_velocity.y,\n                         msg.angular_velocity.z])\n\n        self.accel_filtered = self.alpha * accel + (1 - self.alpha) * self.accel_filtered\n        self.gyro_filtered = self.alpha * gyro + (1 - self.alpha) self.gyro_filtered\n\n        # Store in history\n        self.imu_history.append(msg)\n        if len(self.imu_history) > self.max_history:\n            self.imu_history.pop(0)\n\n    def get_filtered_readings(self) -> tuple:\n        """Get filtered IMU readings."""\n        return self.accel_filtered.copy(), self.gyro_filtered.copy()\n\n\ndef main(args=None):\n    """Run the IMU publisher node."""\n    rclpy.init(args=args)\n\n    try:\n        node = IMUPublisherNode()\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        rclpy.shutdown()\n'})}),"\n",(0,s.jsx)(n.h3,{id:"services-request-reply-communication",children:"Services: Request-Reply Communication"}),"\n",(0,s.jsx)(n.p,{children:"Services implement a synchronous request-reply pattern where a client sends a request and waits for a response. This pattern is appropriate for:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Getting the current robot configuration"}),"\n",(0,s.jsx)(n.li,{children:"Executing one-time commands (calibration, homing)"}),"\n",(0,s.jsx)(n.li,{children:"Querying system status"}),"\n",(0,s.jsx)(n.li,{children:"Running diagnostic routines"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Unlike topics, services are blocking operations and should be used sparingly for time-sensitive robot operations."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nService Server and Client Examples\n\nThis module demonstrates ROS 2 service communication for\nconfiguration queries and command execution.\n"""\n\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional\nfrom dataclasses import dataclass\nimport rclpy\nfrom rclpy.node import Node\nfrom std_srvs.srv import SetBool, Trigger, Trigger\nfrom diagnostic_msgs.srv import AddDiagnostics\nfrom trajectory_msgs.msg import JointTrajectoryPoint\n\n\nclass RobotMode(Enum):\n    """Robot operational modes."""\n    DISABLED = "disabled"\n    CALIBRATION = "calibration"\n    HOMING = "homing"\n    READY = "ready"\n    RUNNING = "running"\n    ERROR = "error"\n    EMERGENCY_STOP = "emergency_stop"\n\n\n@dataclass\nclass JointConfiguration:\n    """Configuration for a single joint."""\n    name: str\n    position: float\n    velocity: float\n    effort: float\n    max_velocity: float\n    max_effort: float\n    is_enabled: bool\n\n\nclass RobotStateService(Node):\n    """\n    Service server for robot state management.\n\n    Provides services for:\n    - Getting current robot mode\n    - Enabling/disabling the robot\n    - Executing homing sequences\n    """\n\n    def __init__(self):\n        super().__init__(\'robot_state_service\')\n\n        # Robot state\n        self._current_mode = RobotMode.DISABLED\n        self._joints: Dict[str, JointConfiguration] = {}\n        self._is_enabled = False\n\n        # Create services\n        self.get_mode_srv = self.create_service(\n            Trigger,\n            \'~/get_mode\',\n            self.get_mode_callback\n        )\n\n        self.enable_srv = self.create_service(\n            SetBool,\n            \'~/enable\',\n            self.enable_callback\n        )\n\n        self.homing_srv = self.create_service(\n            Trigger,\n            \'~/home\',\n            self.homing_callback\n        )\n\n        self.get_joints_srv = self.create_service(\n            Trigger,\n            \'~/get_joints\',\n            self.get_joints_callback\n        )\n\n        self.get_logger().info("Robot State Service initialized")\n\n    def get_mode_callback(self, request, response):\n        """\n        Handle mode query request.\n\n        Returns the current operational mode of the robot.\n        """\n        response.success = True\n        response.message = self._current_mode.value\n        self.get_logger().debug(f"Mode query: {response.message}")\n        return response\n\n    def enable_callback(self, request: SetBool.Request,\n                        response: SetBool.Response):\n        """\n        Handle enable/disable request.\n\n        Args:\n            request: SetBool request with data=True to enable\n\n        Returns:\n            Response indicating success or failure\n        """\n        if request.data:\n            # Enable the robot\n            if self._validate_system():\n                self._is_enabled = True\n                self._current_mode = RobotMode.READY\n                response.success = True\n                response.message = "Robot enabled and ready"\n                self.get_logger().info("Robot enabled")\n            else:\n                response.success = False\n                response.message = "Cannot enable: system validation failed"\n        else:\n            # Disable the robot\n            self._is_enabled = False\n            self._current_mode = RobotMode.DISABLED\n            response.success = True\n            response.message = "Robot disabled"\n            self.get_logger().info("Robot disabled")\n\n        return response\n\n    def homing_callback(self, request: Trigger.Request,\n                        response: Trigger.Response):\n        """\n        Handle homing request.\n\n        Executes a homing sequence to find zero positions for all joints.\n        """\n        if self._current_mode == RobotMode.RUNNING:\n            response.success = False\n            response.message = "Cannot home while robot is running"\n            return response\n\n        self._current_mode = RobotMode.HOMING\n        response.success = True\n        response.message = "Homing sequence initiated"\n\n        # In a real implementation, this would:\n        # 1. Move each joint to its home position\n        # 2. Detect mechanical stops\n        # 3. Set zero position\n        # 4. Verify calibration\n\n        self.get_logger().info("Starting homing sequence")\n        return response\n\n    def get_joints_callback(self, request: Trigger.Request,\n                            response: Trigger.Response):\n        """\n        Handle joint state query request.\n\n        Returns the current state of all configured joints.\n        """\n        response.success = True\n        joint_list = []\n        for name, config in self._joints.items():\n            joint_list.append(f"{name}: pos={config.position:.3f}")\n        response.message = ", ".join(joint_list)\n        return response\n\n    def _validate_system(self) -> bool:\n        """Validate system is ready to be enabled."""\n        # Check all joints are configured\n        if not self._joints:\n            return False\n        # Check all joints have valid calibration\n        # Check safety systems are operational\n        return True\n\n    def add_joint(self, config: JointConfiguration):\n        """Add a joint to the robot configuration."""\n        self._joints[config.name] = config\n\n\nclass RobotStateClient(Node):\n    """\n    Service client for interacting with robot state service.\n\n    Demonstrates how to make service calls from a ROS 2 node.\n    """\n\n    def __init__(self):\n        super().__init__(\'robot_state_client\')\n\n        # Create service clients\n        self.get_mode_client = self.create_client(\n            Trigger,\n            \'~/get_mode\'\n        )\n\n        self.enable_client = self.create_client(\n            SetBool,\n            \'~/enable\'\n        )\n\n        self.wait_for_services()\n\n    def wait_for_services(self):\n        """Wait for services to become available."""\n        while not self.get_mode_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info("Waiting for robot state service...")\n\n    def get_mode(self) -> Optional[str]:\n        """Query current robot mode."""\n        request = Trigger.Request()\n        future = self.get_mode_client.call_async(request)\n        rclpy.spin_until_future_complete(self, future)\n\n        if future.result() is not None:\n            return future.result().message if future.result().success else None\n        return None\n\n    def enable_robot(self, enable: bool = True) -> bool:\n        """\n        Enable or disable the robot.\n\n        Args:\n            enable: True to enable, False to disable\n\n        Returns:\n            True if operation succeeded\n        """\n        request = SetBool.Request()\n        request.data = enable\n\n        future = self.enable_client.call_async(request)\n        rclpy.spin_until_future_complete(self, future)\n\n        if future.result() is not None:\n            return future.result().success\n        return False\n'})}),"\n",(0,s.jsx)(n.h3,{id:"actions-long-running-tasks",children:"Actions: Long-Running Tasks"}),"\n",(0,s.jsx)(n.p,{children:"Actions are designed for long-running tasks that require feedback and can be preempted. They are built on topics and services internally but provide a unified interface for:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Trajectory execution (move arm to position)"}),"\n",(0,s.jsx)(n.li,{children:"Navigation goals (go to location)"}),"\n",(0,s.jsx)(n.li,{children:"Complex procedures (pick and place operations)"}),"\n",(0,s.jsx)(n.li,{children:"Any task that should be cancellable with progress updates"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Actions are ideal for humanoid robot motion control where trajectories may take several seconds and need to be interruptible."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nROS 2 Action Server and Client for Trajectory Execution\n\nActions are ideal for long-running robot movements that require\nfeedback and can be preempted.\n"""\n\nfrom enum import IntEnum\nfrom time import sleep\nimport rclpy\nfrom rclpy.action import ActionServer, ActionClient\nfrom rclpy.node import Node\nfrom rclpy.executors import MultiThreadedExecutor\nfrom control_msgs.action import FollowJointTrajectory\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom builtin_interfaces.msg import Duration\n\n\nclass TrajectoryActionServer(Node):\n    """\n    Action server for executing joint trajectories.\n\n    This server receives trajectory goals and executes them while\n    providing periodic feedback on progress.\n    """\n\n    def __init__(self):\n        super().__init__(\'trajectory_action_server\')\n\n        # Create action server\n        self._action_server = ActionServer(\n            FollowJointTrajectory,\n            \'~/follow_joint_trajectory\',\n            self.execute_callback\n        )\n\n        # Track active trajectories\n        self._active_trajectory = None\n        self._is_cancelled = False\n\n        self.get_logger().info("Trajectory Action Server initialized")\n\n    def execute_callback(self, goal_handle):\n        """\n        Execute a trajectory goal.\n\n        This method is called when a new trajectory goal is received.\n        It executes the trajectory while providing feedback and\n        handling cancellation requests.\n        """\n        self.get_logger().info("Received trajectory goal")\n\n        goal = goal_handle.request.trajectory\n        self._is_cancelled = False\n\n        # Extract trajectory information\n        joint_names = goal.joint_names\n        points = goal.points\n\n        if not points:\n            goal_handle.succeed()\n            return\n\n        # Calculate total duration\n        total_duration = points[-1].time_from_start.sec + \\\n                        points[-1].time_from_start.nanosec / 1e9\n\n        # Execute trajectory with feedback\n        feedback = FollowJointTrajectory.Feedback()\n        result = FollowJointTrajectory.Result()\n\n        start_time = self.get_clock().now()\n\n        for i, point in enumerate(points):\n            # Check for cancellation\n            if self._is_cancelled:\n                result.error_code = FollowJointTrajectory.Result.INVALID_GOAL\n                result.error_string = "Trajectory cancelled"\n                goal_handle.aborted(result)\n                self._active_trajectory = None\n                return\n\n            # Calculate current progress\n            current_time = self.get_clock().now()\n            elapsed = (current_time - start_time).nanoseconds / 1e9\n\n            # Publish feedback\n            feedback.header.stamp = current_time.to_msg()\n            feedback.desired = point\n            goal_handle.publish_feedback(feedback)\n\n            # Wait for trajectory timing\n            target_time = point.time_from_start.sec + point.time_from_start.nanosec / 1e9\n            sleep(max(0, target_time - elapsed))\n\n            self.get_logger().debug(f"Trajectory point {i+1}/{len(points)}")\n\n        # Trajectory complete\n        result.error_code = FollowJointTrajectory.Result.SUCCESSFUL\n        result.error_string = "Trajectory executed successfully"\n        goal_handle.succeed(result)\n        self._active_trajectory = None\n\n        return result\n\n    def cancel_active_trajectory(self):\n        """Cancel the currently executing trajectory."""\n        self._is_cancelled = True\n\n\nclass TrajectoryActionClient(Node):\n    """\n    Action client for sending trajectory goals.\n\n    Demonstrates how to send trajectories and handle feedback.\n    """\n\n    def __init__(self):\n        super().__init__(\'trajectory_action_client\')\n\n        # Create action client\n        self._action_client = ActionClient(\n            self,\n            FollowJointTrajectory,\n            \'~/follow_joint_trajectory\'\n        )\n\n        self._goal_handle = None\n\n        self.get_logger().info("Trajectory Action Client initialized")\n\n    def send_trajectory(self, joint_names: list,\n                        positions: list, duration: float) -> bool:\n        """\n        Send a trajectory goal to the action server.\n\n        Args:\n            joint_names: List of joint names\n            positions: Target positions for each joint\n            duration: Time to reach target in seconds\n\n        Returns:\n            True if goal was accepted\n        """\n        # Create trajectory message\n        trajectory = JointTrajectory()\n        trajectory.joint_names = joint_names\n\n        # Create trajectory point\n        point = JointTrajectoryPoint()\n        point.positions = positions\n        point.velocities = [0.0] * len(positions)\n        point.accelerations = [0.0] * len(positions)\n        point.time_from_start = Duration(sec=int(duration),\n                                          nanosec=int((duration % 1) * 1e9))\n        trajectory.points = [point]\n\n        # Create goal\n        goal = FollowJointTrajectory.Goal()\n        goal.trajectory = trajectory\n\n        # Send goal\n        self.get_logger().info("Sending trajectory goal")\n        self._goal_handle = self._action_client.send_goal(\n            goal,\n            feedback_callback=self.feedback_callback\n        )\n\n        return self._goal_handle is not None\n\n    def feedback_callback(self, feedback):\n        """Handle feedback from the action server."""\n        self.get_logger().debug(f"Feedback: desired time {feedback.feedback.desired.time_from_start}")\n\n    def cancel_goal(self):\n        """Cancel the current goal if active."""\n        if self._goal_handle:\n            self._goal_handle.cancel_goal()\n            self._goal_handle = None\n'})}),"\n",(0,s.jsx)(n.h2,{id:"23-building-ros-2-packages-with-python",children:"2.3 Building ROS 2 Packages with Python"}),"\n",(0,s.jsx)(n.p,{children:"Creating a well-structured ROS 2 package is essential for maintaining humanoid robot software. This section covers package organization, configuration, and best practices."}),"\n",(0,s.jsx)(n.h3,{id:"package-structure",children:"Package Structure"}),"\n",(0,s.jsx)(n.p,{children:"A ROS 2 package for humanoid robotics should follow this structure:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"humanoid_control/\n  package.xml          # Package metadata and dependencies\n  setup.py             # Build and installation configuration\n  setup.cfg            # Build tool configuration\n  humanoid_control/\n    __init__.py        # Package initialization\n    nodes/             # Executable node scripts\n      balance_controller.py\n      trajectory_executor.py\n    modules/           # Reusable Python modules\n      kinematics.py\n      dynamics.py\n      filters.py\n    config/            # Configuration files\n      control_params.yaml\n      joint_limits.yaml\n    launch/            # Launch files\n      bringup.launch.py\n    tests/             # Unit and integration tests\n      test_kinematics.py\n"})}),"\n",(0,s.jsx)(n.h3,{id:"package-configuration-files",children:"Package Configuration Files"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- package.xml --\x3e\n<?xml version="1.0"?>\n<?xml-model href="http://download.ros.org/schema/package_format3.xsd"\n            schematypens="http://www.w3.org/2001/XMLSchema"?>\n<package format="3">\n  <name>humanoid_control</name>\n  <version>1.0.0</version>\n  <description>Control software for humanoid robot</description>\n\n  <maintainer email="developer@humanoid.robot">\n    Humanoid Robotics Team\n  </maintainer>\n\n  <license>MIT</license>\n\n  <exec_depend>rclpy</exec_depend>\n  <exec_depend>std_msgs</exec_depend>\n  <exec_depend>sensor_msgs</exec_depend>\n  <exec_depend>geometry_msgs</exec_depend>\n  <exec_depend>trajectory_msgs</exec_depend>\n  <exec_depend>control_msgs</exec_depend>\n  <exec_depend>builtin_interfaces</exec_depend>\n\n  <test_depend>pytest</test_depend>\n  <test_depend>launch_testing</test_depend>\n\n  <member_of_group>rosidl_interface_packages</member_of_group>\n</package>\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# setup.py\nfrom setuptools import setup\nimport os\n\npackage_name = 'humanoid_control'\n\nsetup(\n    name=package_name,\n    version='1.0.0',\n    packages=[package_name],\n    data_files=[\n        ('share/ament_index/resource_index/packages',\n            ['resource/' + package_name]),\n        ('share/' + package_name, ['package.xml']),\n        (os.path.join('share', package_name, 'config'),\n         glob('config/*.yaml')),\n        (os.path.join('share', package_name, 'launch'),\n         glob('launch/*.launch.py')),\n    ],\n    install_requires=['numpy', 'scipy'],\n    zip_safe=True,\n    author='Humanoid Robotics Team',\n    maintainer='Humanoid Robotics Team',\n    keywords=['robotics', 'humanoid', 'control'],\n    classifiers=[\n        'Environment :: Robots',\n        'Intended Audience :: Developers',\n        'Topic :: Scientific/Engineering :: Artificial Intelligence',\n    ],\n    description='Control software for humanoid robot platforms',\n    license='MIT',\n    tests_require=['pytest'],\n    entry_points={\n        'console_scripts': [\n            'balance_controller = humanoid_control.nodes.balance_controller:main',\n            'trajectory_executor = humanoid_control.nodes.trajectory_executor:main',\n        ],\n    },\n)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"entry-point-scripts",children:"Entry Point Scripts"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nBalance Controller Node Entry Point\n\nThis is the main entry point for the balance controller node.\nIt handles ROS 2 initialization and graceful shutdown.\n"""\n\nimport sys\nimport signal\nimport rclpy\nfrom humanoid_control.nodes.balance_controller import BalanceControllerNode\n\n\ndef signal_handler(signum, frame):\n    """Handle shutdown signals gracefully."""\n    rclpy.shutdown()\n\n\ndef main(args=None):\n    """Main entry point for the balance controller."""\n    # Register signal handlers\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n\n    # Initialize ROS\n    rclpy.init(args=args)\n\n    try:\n        # Create and spin the node\n        node = BalanceControllerNode()\n        rclpy.spin(node)\n    except Exception as e:\n        print(f"Node error: {e}")\n        sys.exit(1)\n    finally:\n        # Cleanup\n        rclpy.shutdown()\n\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,s.jsx)(n.h2,{id:"24-launch-files-and-parameter-management",children:"2.4 Launch Files and Parameter Management"}),"\n",(0,s.jsx)(n.p,{children:"Launch files enable complex system startup, coordinating the initialization of multiple nodes with appropriate parameters. ROS 2 uses Python-based launch files for flexibility."}),"\n",(0,s.jsx)(n.h3,{id:"python-launch-files",children:"Python Launch Files"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\"\"\"\nHumanoid Robot System Launch File\n\nThis launch file starts all components needed for humanoid robot\noperation including sensors, controllers, and state estimation.\n\"\"\"\n\nimport os\nfrom launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription, DeclareLaunchArgument\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.substitutions import FindPackageShare\nfrom launch_ros.actions import Node\n\n\ndef generate_launch_description():\n    \"\"\"\n    Generate the launch description for the humanoid robot system.\n\n    This function defines all nodes, parameters, and remappings\n    needed to bring up the complete robot system.\n    \"\"\"\n\n    # Declare launch arguments\n    robot_model = LaunchArgument(\n        'robot_model',\n        default_value='atlas_v2',\n        description='Robot model identifier'\n    )\n\n    use_sim = LaunchArgument(\n        'use_sim',\n        default_value='false',\n        description='Use simulation instead of real hardware'\n    )\n\n    control_mode = LaunchArgument(\n        'control_mode',\n        default_value='position',\n        choices=['position', 'velocity', 'effort', 'impedance'],\n        description='Joint control mode'\n    )\n\n    # Package share directories\n    pkg_share = FindPackageShare('humanoid_control')\n    pkg_bringup = FindPackageShare('humanoid_bringup')\n    pkg_description = FindPackageShare('humanoid_description')\n\n    # Configuration files\n    params_file = PathJoinSubstitution([\n        pkg_share, 'config', 'control_params.yaml'\n    ])\n\n    joint_limits_file = PathJoinSubstitution([\n        pkg_share, 'config', 'joint_limits.yaml'\n    ])\n\n    # URDF/XACRO file\n    urdf_file = PathJoinSubstitution([\n        pkg_description, 'urdf', 'humanoid.urdf.xacro'\n    ])\n\n    # Create the launch description\n    ld = LaunchDescription()\n\n    # Add arguments\n    ld.add_action(robot_model)\n    ld.add_action(use_sim)\n    ld.add_action(control_mode)\n\n    # Robot state publisher (URDF)\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        name='robot_state_publisher',\n        parameters=[{\n            'robot_description': urdf_file,\n            'use_tf_static': True,\n        }],\n        output='screen'\n    )\n    ld.add_action(robot_state_publisher)\n\n    # IMU publisher node\n    imu_publisher = Node(\n        package='humanoid_control',\n        executable='imu_publisher',\n        name='imu_publisher',\n        parameters=[\n            params_file,\n            {'frame_id': 'imu_link'},\n            {'publish_rate': 200.0}\n        ],\n        output='screen'\n    )\n    ld.add_action(imu_publisher)\n\n    # Balance controller node\n    balance_controller = Node(\n        package='humanoid_control',\n        executable='balance_controller',\n        name='balance_controller',\n        parameters=[\n            params_file,\n            joint_limits_file,\n            {'control_mode': control_mode},\n            {'use_simulation': use_sim}\n        ],\n        output='screen'\n    )\n    ld.add_action(balance_controller)\n\n    # Trajectory executor\n    trajectory_executor = Node(\n        package='humanoid_control',\n        executable='trajectory_executor',\n        name='trajectory_executor',\n        parameters=[\n            params_file,\n            joint_limits_file\n        ],\n        output='screen'\n    )\n    ld.add_action(trajectory_executor)\n\n    # Joint state publisher (for visualization)\n    joint_state_publisher = Node(\n        package='joint_state_publisher',\n        executable='joint_state_publisher',\n        name='joint_state_publisher',\n        parameters=[{\n            'use_smallest_joint_limits': True\n        }],\n        condition=UnlessCondition(use_sim)\n    )\n    ld.add_action(joint_state_publisher)\n\n    # RViz visualization\n    rviz_config = PathJoinSubstitution([\n        pkg_bringup, 'rviz', 'humanoid.rviz'\n    ])\n\n    rviz_node = Node(\n        package='rviz2',\n        executable='rviz2',\n        name='rviz2',\n        arguments=['-d', rviz_config],\n        output='screen'\n    )\n    ld.add_action(rviz_node)\n\n    return ld\n"})}),"\n",(0,s.jsx)(n.h3,{id:"parameter-management-with-yaml",children:"Parameter Management with YAML"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'# control_params.yaml\n# Humanoid Robot Control Parameters\n# See Appendix B for simulation setup details\n\n/**:\n  ros__parameters:\n    # Node configuration\n    use_sim_time: false\n\n    # Control loop parameters\n    control_rate: 200.0  # Hz\n    control_mode: "position"\n\n    # Balance controller parameters\n    balance_controller:\n      kp: [100.0, 100.0, 50.0]\n      kd: [10.0, 10.0, 5.0]\n      ki: [1.0, 1.0, 0.5]\n      com_height: 0.9  # meters\n      foot_separation: 0.15  # meters\n      max_tilt_angle: 0.1  # radians\n      recovery_gain: 2.0\n\n    # Joint limits (applied from joint_limits.yaml)\n    joint_limits:\n      left_hip_yaw:\n        min_position: -1.5\n        max_position: 1.5\n        max_velocity: 2.0\n        max_effort: 100.0\n      right_hip_yaw:\n        min_position: -1.5\n        max_position: 1.5\n        max_velocity: 2.0\n        max_effort: 100.0\n      # ... additional joints\n\n    # Sensor configuration\n    sensors:\n      imu:\n        frame_id: "imu_link"\n        publish_rate: 200.0\n        accel_range: 16.0  # g\n        gyro_range: 2000.0  # deg/s\n      force_torque:\n        left_foot:\n          frame_id: "left_foot_link"\n          sample_rate: 100.0\n        right_foot:\n          frame_id: "right_foot_link"\n          sample_rate: 100.0\n\n    # Logging configuration\n    logging:\n      level: "INFO"\n      file: "/var/log/humanoid/control.log"\n'})}),"\n",(0,s.jsx)(n.h2,{id:"25-complete-publisher-subscriber-example",children:"2.5 Complete Publisher-Subscriber Example"}),"\n",(0,s.jsx)(n.p,{children:"The following example demonstrates a complete working system with publishers and subscribers for a humanoid robot application."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\"\"\"\nComplete Humanoid Robot State Publisher-Subscriber System\n\nThis module demonstrates a complete ROS 2 system for humanoid robot\nstate management including joint state publishing, IMU data streaming,\nand state subscription for monitoring.\n\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.lifecycle import LifecycleNode, LifecycleState\nfrom rclpy.lifecycle import publisher_callback, transition_callback\nfrom rclpy.lifecycle import CallbackReturn\nfrom sensor_msgs.msg import JointState, Imu\nfrom std_msgs.msg import Float64MultiArray, Bool\nfrom geometry_msgs.msg import WrenchStamped, TransformStamped\nimport numpy as np\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nimport transforms3d as t3d\n\n\n@dataclass\nclass JointStateData:\n    \"\"\"Container for joint state information.\"\"\"\n    position: float\n    velocity: float\n    effort: float\n    timestamp: float\n\n\nclass HumanoidStatePublisher(Node):\n    \"\"\"\n    Lifecycle node for publishing humanoid robot state.\n\n    This node manages the complete state publishing system including:\n    - Joint states (position, velocity, effort)\n    - IMU data (linear acceleration, angular velocity)\n    - End-effector wrenches (force/torque)\n    - Base transform (pose in world frame)\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('humanoid_state_publisher')\n\n        # Declare parameters\n        self.declare_parameter('robot_name', 'humanoid')\n        self.declare_parameter('publish_rate', 100.0)\n        self.declare_parameter('joint_names', [\n            'left_hip_yaw', 'left_hip_pitch', 'left_hip_roll',\n            'left_knee_pitch', 'left_ankle_pitch', 'left_ankle_roll',\n            'right_hip_yaw', 'right_hip_pitch', 'right_hip_roll',\n            'right_knee_pitch', 'right_ankle_pitch', 'right_ankle_roll',\n            'waist_yaw', 'waist_pitch', 'waist_roll',\n            'left_shoulder_pitch', 'left_shoulder_roll', 'left_shoulder_yaw',\n            'left_elbow_pitch', 'left_wrist_roll', 'left_wrist_pitch',\n            'right_shoulder_pitch', 'right_shoulder_roll', 'right_shoulder_yaw',\n            'right_elbow_pitch', 'right_wrist_roll', 'right_wrist_pitch',\n            'neck_pitch', 'neck_yaw'\n        ])\n\n        self.robot_name = self.get_parameter('robot_name').value\n        self.publish_rate = self.get_parameter('publish_rate').value\n        self.joint_names = self.get_parameter('joint_names').value\n\n        # Initialize joint state\n        self.joint_states: Dict[str, JointStateData] = {}\n        for name in self.joint_names:\n            self.joint_states[name] = JointStateData(0.0, 0.0, 0.0, 0.0)\n\n        # Create publishers with QoS profiles\n        qos_sensor = rclpy.qos.QoSProfile(\n            reliability=rclpy.qos.ReliabilityPolicy.BEST_EFFORT,\n            durability=rclpy.qos.DurabilityPolicy.VOLATILE,\n            depth=1\n        )\n\n        qos_state = rclpy.qos.QoSProfile(\n            reliability=rclpy.qos.ReliabilityPolicy.RELIABLE,\n            durability=rclpy.qos.DurabilityPolicy.TRANSIENT_LOCAL,\n            depth=10\n        )\n\n        # Joint state publisher\n        self.joint_state_pub = self.create_publisher(\n            JointState,\n            '~/joint_states',\n            qos_state\n        )\n\n        # IMU publisher\n        self.imu_pub = self.create_publisher(\n            Imu,\n            '~/imu/data',\n            qos_sensor\n        )\n\n        # Base transform publisher\n        self.tf_pub = self.create_publisher(\n            TransformStamped,\n            '~/base_transform',\n            qos_state\n        )\n\n        # Timer for periodic publishing\n        self.timer = self.create_timer(\n            1.0 / self.publish_rate,\n            self.publish_state\n        )\n\n        # Simulated state\n        self.sim_time = 0.0\n        self.base_position = np.array([0.0, 0.0, 0.88])  # Standing height\n\n        self.get_logger().info(f\"State publisher initialized with {len(self.joint_names)} joints\")\n\n    def publish_state(self):\n        \"\"\"Publish all state information.\"\"\"\n        self.sim_time += 1.0 / self.publish_rate\n\n        # Update simulated state\n        self._update_simulated_state()\n\n        # Publish joint states\n        self._publish_joint_states()\n\n        # Publish IMU data\n        self._publish_imu_data()\n\n        # Publish base transform\n        self._publish_base_transform()\n\n    def _update_simulated_state(self):\n        \"\"\"Update simulated joint states.\"\"\"\n        for name, state in self.joint_states.items():\n            # Add small oscillation for demonstration\n            state.timestamp = self.sim_time\n            if 'knee' in name or 'elbow' in name:\n                # Simulate slight knee/elbow flexing\n                state.position = 0.02 * np.sin(self.sim_time * 2.0)\n            else:\n                # Small oscillations\n                state.position = 0.005 * np.sin(self.sim_time)\n\n    def _publish_joint_states(self):\n        \"\"\"Publish joint state message.\"\"\"\n        msg = JointState()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = 'world'\n\n        msg.name = self.joint_names\n        msg.position = [self.joint_states[n].position for n in self.joint_names]\n        msg.velocity = [self.joint_states[n].velocity for n in self.joint_names]\n        msg.effort = [self.joint_states[n].effort for n in self.joint_names]\n\n        self.joint_state_pub.publish(msg)\n\n    def _publish_imu_data(self):\n        \"\"\"Publish IMU data.\"\"\"\n        from geometry_msgs.msg import Vector3, Quaternion\n\n        msg = Imu()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = 'imu_link'\n\n        # Simulated IMU data (gravity + small motion)\n        msg.linear_acceleration = Vector3(\n            x=0.05 * np.sin(self.sim_time),\n            y=0.03 * np.cos(self.sim_time),\n            z=9.81\n        )\n\n        msg.angular_velocity = Vector3(\n            x=0.01 * np.sin(self.sim_time),\n            y=0.01 * np.cos(self.sim_time),\n            z=0.005 * np.sin(self.sim_time * 0.5)\n        )\n\n        # Orientation from simple tilt estimate\n        roll = 0.02 * np.sin(self.sim_time)\n        pitch = 0.02 * np.cos(self.sim_time)\n        quat = t3d.euler.euler2quat(roll, pitch, 0.0)\n        msg.orientation = Quaternion(\n            w=quat[0], x=quat[1], y=quat[2], z=quat[3]\n        )\n\n        self.imu_pub.publish(msg)\n\n    def _publish_base_transform(self):\n        \"\"\"Publish base link transform.\"\"\"\n        msg = TransformStamped()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = 'world'\n        msg.child_frame_id = 'base_link'\n\n        # Simulated base motion (standing still with sway)\n        sway_x = 0.01 * np.sin(self.sim_time * 0.5)\n        sway_y = 0.008 * np.cos(self.sim_time * 0.7)\n\n        msg.transform.translation.x = sway_x\n        msg.transform.translation.y = sway_y\n        msg.transform.translation.z = self.base_position[2]\n\n        # Small base orientation change\n        roll = 0.01 * np.sin(self.sim_time * 0.3)\n        pitch = 0.01 * np.cos(self.sim_time * 0.3)\n        quat = t3d.euler.euler2quat(roll, pitch, 0.0)\n        msg.transform.rotation = Quaternion(\n            w=quat[0], x=quat[1], y=quat[2], z=quat[3]\n        )\n\n        self.tf_pub.publish(msg)\n\n\nclass HumanoidStateSubscriber(Node):\n    \"\"\"\n    Node for subscribing to and processing humanoid robot state.\n\n    This node demonstrates subscriber patterns for state monitoring\n    and provides utilities for state analysis.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('humanoid_state_subscriber')\n\n        # Subscription QoS\n        qos = rclpy.qos.QoSProfile(\n            reliability=rclpy.qos.ReliabilityPolicy.RELIABLE,\n            depth=10\n        )\n\n        # Create subscriptions\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            '~/joint_states',\n            self.joint_state_callback,\n            qos\n        )\n\n        self.imu_sub = self.create_subscription(\n            Imu,\n            '~/imu/data',\n            self.imu_callback,\n            qos\n        )\n\n        # State storage\n        self.latest_joint_state: Optional[JointState] = None\n        self.latest_imu: Optional[Imu] = None\n        self.joint_history: Dict[str, List[float]] = {n: [] for n in range(100)}\n\n        # Computed metrics\n        self.total_joint_positions = 0.0\n        self.num_joints = 28\n\n        self.get_logger().info(\"State subscriber initialized\")\n\n    def joint_state_callback(self, msg: JointState):\n        \"\"\"Process incoming joint state message.\"\"\"\n        self.latest_joint_state = msg\n\n        # Calculate total joint movement\n        self.total_joint_positions = sum(abs(p) for p in msg.position)\n\n        # Store in history\n        for i, name in enumerate(msg.name):\n            if name not in self.joint_history:\n                self.joint_history[name] = []\n            self.joint_history[name].append(msg.position[i])\n\n            # Keep history limited\n            if len(self.joint_history[name]) > 100:\n                self.joint_history[name].pop(0)\n\n    def imu_callback(self, msg: Imu):\n        \"\"\"Process incoming IMU message.\"\"\"\n        self.latest_imu = msg\n\n        # Could implement gravity rejection, orientation estimation, etc.\n\n    def get_joint_position(self, joint_name: str) -> Optional[float]:\n        \"\"\"Get the current position of a specific joint.\"\"\"\n        if self.latest_joint_state is None:\n            return None\n\n        for i, name in enumerate(self.latest_joint_state.name):\n            if name == joint_name:\n                return self.latest_joint_state.position[i]\n        return None\n\n    def get_all_joint_positions(self) -> Dict[str, float]:\n        \"\"\"Get all joint positions as a dictionary.\"\"\"\n        if self.latest_joint_state is None:\n            return {}\n\n        return dict(zip(\n            self.latest_joint_state.name,\n            self.latest_joint_state.position\n        ))\n\n    def is_robot_moving(self, threshold: float = 0.001) -> bool:\n        \"\"\"Check if the robot is currently moving.\"\"\"\n        if self.latest_joint_state is None:\n            return False\n\n        velocities = self.latest_joint_state.velocity\n        return any(abs(v) > threshold for v in velocities)\n\n\ndef main(args=None):\n    \"\"\"Run the state publisher node.\"\"\"\n    rclpy.init(args=args)\n\n    try:\n        # Create and spin the publisher\n        publisher = HumanoidStatePublisher()\n        rclpy.spin(publisher)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        rclpy.shutdown()\n\n\nif __name__ == \"__main__\":\n    main()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"hardware-requirements-reference",children:"Hardware Requirements Reference"}),"\n",(0,s.jsx)(n.p,{children:"For running ROS 2 humanoid robot software, the following specifications are recommended:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Component"}),(0,s.jsx)(n.th,{children:"Minimum"}),(0,s.jsx)(n.th,{children:"Recommended"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"CPU"}),(0,s.jsx)(n.td,{children:"4-core @ 2.0 GHz"}),(0,s.jsx)(n.td,{children:"8-core @ 3.5 GHz"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"RAM"}),(0,s.jsx)(n.td,{children:"8 GB"}),(0,s.jsx)(n.td,{children:"32 GB DDR4"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Storage"}),(0,s.jsx)(n.td,{children:"64 GB SSD"}),(0,s.jsx)(n.td,{children:"256 GB NVMe SSD"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"GPU"}),(0,s.jsx)(n.td,{children:"Integrated"}),(0,s.jsx)(n.td,{children:"NVIDIA RTX 3060+"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Network"}),(0,s.jsx)(n.td,{children:"1 Gbps Ethernet"}),(0,s.jsx)(n.td,{children:"2.5 Gbps or WiFi 6"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Power"}),(0,s.jsx)(n.td,{children:"65W TDP"}),(0,s.jsx)(n.td,{children:"125W TDP"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"For simulation environments, see Appendix B which covers Gazebo simulation setup for testing ROS 2 code without physical hardware."}),"\n",(0,s.jsx)(n.h2,{id:"chapter-summary",children:"Chapter Summary"}),"\n",(0,s.jsx)(n.p,{children:"This chapter covered the fundamental concepts of ROS 2 that are essential for humanoid robot software development:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"ROS 2 Architecture"}),": The layered architecture from application code through the ROS client library to DDS middleware provides a robust foundation for production robotics systems."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Communication Paradigms"}),": Topics provide efficient one-to-many data streaming, services enable synchronous request-reply operations, and actions support long-running tasks with feedback."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Package Development"}),": Well-structured packages with proper dependencies, entry points, and configuration files are essential for maintainable humanoid robot software."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Launch Files"}),": Python-based launch files enable complex system orchestration with parameter management and conditional node launching."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameter Management"}),": YAML-based configuration files provide clean separation between code and configuration, enabling easy tuning without code changes."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Nodes"}),": Single-purpose executables that form the building blocks of ROS 2 systems"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Topics"}),": Publish-subscribe communication for streaming data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Services"}),": Request-reply communication for synchronous operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Actions"}),": Long-running tasks with feedback and preemption support"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"QoS Policies"}),": Configurable reliability and performance characteristics"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lifecycle Management"}),": Controlled node startup and shutdown procedures"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"key-terminology",children:"Key Terminology"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"DDS (Data Distribution Service)"}),": Underlying communication middleware providing reliable data distribution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"QoS (Quality of Service)"}),": Policies controlling communication behavior"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Workspace"}),": Directory containing ROS 2 packages for building"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Package"}),": Fundamental software organization unit in ROS 2"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Colcon"}),": Build tool for ROS 2 packages"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"RMW"}),": ROS Middleware Interface abstracting DDS implementations"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["ROS 2 Documentation: ",(0,s.jsx)(n.a,{href:"https://docs.ros.org/en/humble/",children:"https://docs.ros.org/en/humble/"})]}),"\n",(0,s.jsxs)(n.li,{children:["ROS 2 Design Articles: ",(0,s.jsx)(n.a,{href:"https://design.ros2.org/",children:"https://design.ros2.org/"})]}),"\n",(0,s.jsxs)(n.li,{children:["DDS Specification: ",(0,s.jsx)(n.a,{href:"https://www.omg.org/omg-dds-portal/",children:"https://www.omg.org/omg-dds-portal/"})]}),"\n",(0,s.jsx)(n.li,{children:'"Programming Robots with ROS" - Morgan Quigley et al.'}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"next-chapter",children:"Next Chapter"}),"\n",(0,s.jsxs)(n.p,{children:["Chapter 3 explores ",(0,s.jsx)(n.strong,{children:"Actuators and Movement Systems"}),", examining the mechanical and control aspects of robot actuation. You will learn about motor types, joint design, kinematics, and the control algorithms that enable humanoid robots to move."]}),"\n",(0,s.jsx)(n.h3,{id:"transition-to-simulation",children:"Transition to Simulation"}),"\n",(0,s.jsxs)(n.p,{children:["After completing Part 2, Part 3 covers ",(0,s.jsx)(n.strong,{children:"Simulation and Testing"})," where you will apply ROS 2 concepts in Gazebo simulation environments. This allows testing control algorithms without risking physical hardware damage."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Part 2: ROS 2 Fundamentals"})," | ",(0,s.jsx)(n.a,{href:"part-2-ros2/02a-week-3-5-overview",children:"Weeks 3-5 Overview"})," | ",(0,s.jsx)(n.a,{href:"part-3-simulation/gazebo-unity-simulation",children:"Part 3: Simulation"})]})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(6540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);