"use strict";(globalThis.webpackChunkbook=globalThis.webpackChunkbook||[]).push([[477],{7237:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"appendix/B-simulation-setup","title":"Appendix B: Simulation Setup Guide","description":"Comprehensive setup guide for Gazebo, NVIDIA Isaac Sim, Unity, and container-based simulation environments","source":"@site/docs/appendix/B-simulation-setup.md","sourceDirName":"appendix","slug":"/appendix/B-simulation-setup","permalink":"/Ary-s-Physical-Humanoid-Robotics/docs/appendix/B-simulation-setup","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/appendix/B-simulation-setup.md","tags":[],"version":"current","sidebarPosition":71,"frontMatter":{"title":"Appendix B: Simulation Setup Guide","sidebar_position":71,"description":"Comprehensive setup guide for Gazebo, NVIDIA Isaac Sim, Unity, and container-based simulation environments"},"sidebar":"tutorialSidebar","previous":{"title":"Appendix A: Hardware Specifications","permalink":"/Ary-s-Physical-Humanoid-Robotics/docs/appendix/hardware-specifications"},"next":{"title":"Appendix C: Community Resources","permalink":"/Ary-s-Physical-Humanoid-Robotics/docs/appendix/C-community-resources"}}');var t=i(4848),r=i(8453);const o={title:"Appendix B: Simulation Setup Guide",sidebar_position:71,description:"Comprehensive setup guide for Gazebo, NVIDIA Isaac Sim, Unity, and container-based simulation environments"},a="Appendix B: Simulation Setup Guide",l={},c=[{value:"B.1 Gazebo Simulation Setup",id:"b1-gazebo-simulation-setup",level:2},{value:"B.1.1 Installation on Ubuntu 22.04",id:"b11-installation-on-ubuntu-2204",level:3},{value:"B.1.2 Verifying Your Installation",id:"b12-verifying-your-installation",level:3},{value:"B.1.3 Creating a Humanoid Simulation Workspace",id:"b13-creating-a-humanoid-simulation-workspace",level:3},{value:"B.1.4 Troubleshooting Common Issues",id:"b14-troubleshooting-common-issues",level:3},{value:"B.2 NVIDIA Isaac Sim Setup",id:"b2-nvidia-isaac-sim-setup",level:2},{value:"B.2.1 System Requirements",id:"b21-system-requirements",level:3},{value:"B.2.2 Installation Steps",id:"b22-installation-steps",level:3},{value:"B.2.3 Licensing Information",id:"b23-licensing-information",level:3},{value:"B.2.4 Getting Started Workflow",id:"b24-getting-started-workflow",level:3},{value:"B.2.5 ROS 2 Integration with Isaac Sim",id:"b25-ros-2-integration-with-isaac-sim",level:3},{value:"B.3 Unity for Robotics",id:"b3-unity-for-robotics",level:2},{value:"B.3.1 Unity Installation",id:"b31-unity-installation",level:3},{value:"B.3.2 ROS-Unity Integration Setup",id:"b32-ros-unity-integration-setup",level:3},{value:"B.3.3 Basic Unity Robotics Project Setup",id:"b33-basic-unity-robotics-project-setup",level:3},{value:"B.3.4 Unity-ROS 2 Communication Setup",id:"b34-unity-ros-2-communication-setup",level:3},{value:"B.4 Container and Virtual Machine Setup",id:"b4-container-and-virtual-machine-setup",level:2},{value:"B.4.1 Docker Setup for Simulation",id:"b41-docker-setup-for-simulation",level:3},{value:"B.4.2 Docker Compose for Multi-Container Simulation",id:"b42-docker-compose-for-multi-container-simulation",level:3},{value:"B.4.3 NVIDIA Isaac Sim Container",id:"b43-nvidia-isaac-sim-container",level:3},{value:"B.4.4 Virtual Machine Recommendations",id:"b44-virtual-machine-recommendations",level:3},{value:"B.5 Performance Optimization",id:"b5-performance-optimization",level:2},{value:"B.5.1 GPU Optimization",id:"b51-gpu-optimization",level:3},{value:"B.5.2 Memory Management",id:"b52-memory-management",level:3},{value:"B.5.3 Simulation Speed Optimization",id:"b53-simulation-speed-optimization",level:3},{value:"B.5.4 Multi-Node Distributed Simulation",id:"b54-multi-node-distributed-simulation",level:3},{value:"B.5.5 Performance Monitoring Tools",id:"b55-performance-monitoring-tools",level:3},{value:"B.6 Summary",id:"b6-summary",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"appendix-b-simulation-setup-guide",children:"Appendix B: Simulation Setup Guide"})}),"\n",(0,t.jsx)(n.p,{children:"This appendix provides detailed setup instructions for the primary simulation tools used throughout this book. Proper simulation environment configuration is essential for developing and testing humanoid robotics algorithms before deploying to physical hardware."}),"\n",(0,t.jsx)(n.admonition,{title:"Prerequisites",type:"note",children:(0,t.jsx)(n.p,{children:"Before beginning any simulation setup, ensure your system meets the minimum hardware requirements outlined in Chapter 2. For GPU-intensive simulations, a dedicated graphics card with CUDA support is strongly recommended."})}),"\n",(0,t.jsx)(n.h2,{id:"b1-gazebo-simulation-setup",children:"B.1 Gazebo Simulation Setup"}),"\n",(0,t.jsx)(n.p,{children:"Gazebo is an open-source robotics simulator that provides accurate simulation of indoor and outdoor environments. It integrates seamlessly with ROS (Robot Operating System) and is the de facto standard for robotics research and development."}),"\n",(0,t.jsx)(n.h3,{id:"b11-installation-on-ubuntu-2204",children:"B.1.1 Installation on Ubuntu 22.04"}),"\n",(0,t.jsx)(n.p,{children:"Ubuntu 22.04 LTS (Jammy Jellyfish) is the recommended operating system for Gazebo simulation with ROS 2 Humble. The following steps outline a complete installation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'# Update package lists\nsudo apt update\nsudo apt upgrade -y\n\n# Install required dependencies\nsudo apt install -y \\\n    curl \\\n    gnupg2 \\\n    lsb-release \\\n    ca-certificates \\\n    wget \\\n    software-properties-common \\\n    apt-transport-https \\\n    git\n\n# Add ROS 2 repository\nsudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key \\\n    -o /usr/share/keyrings/ros-archive-keyring.gpg\necho "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release && echo $UBUNTU_CODENAME) main" \\\n    | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null\n\n# Install ROS 2 Humble desktop installation\nsudo apt update\nsudo apt install -y ros-humble-desktop\n\n# Initialize rosdep (dependency manager for ROS)\nsudo rosdep init\nrosdep update\n\n# Install Gazebo simulation packages\nsudo apt install -y \\\n    ros-humble-gazebo-ros-pkgs \\\n    ros-humble-gazebo-ros2-control \\\n    ros-humble-gazebo-ros2-multicontroller \\\n    ros-humble-gazebo-plugins \\\n    ros-humble-xacro \\\n    ros-humble-robot-state-publisher \\\n    ros-humble-joint-state-publisher \\\n    ros-humble-joint-trajectory-controller \\\n    ros-humble-ros2-controllers\n\n# Install additional useful tools\nsudo apt install -y \\\n    python3-colcon-common-extensions \\\n    python3-argcomplete \\\n    ros-humble-rviz2 \\\n    ros-humble-rqt \\\n    ros-humble-rqt-graph \\\n    ros-humble-rqt-robot-steering\n\n# Set up environment variables (add to ~/.bashrc for persistence)\necho "source /opt/ros/humble/setup.bash" >> ~/.bashrc\necho "source /usr/share/colcon_argcomplete/hook/colcon-argcomplete.bash" >> ~/.bashrc\necho "export GAZEBO_MODEL_PATH=$GAZEBO_MODEL_PATH:/usr/share/gazebo-11/models" >> ~/.bashrc\n\n# Reload bash configuration\nsource ~/.bashrc\n'})}),"\n",(0,t.jsx)(n.h3,{id:"b12-verifying-your-installation",children:"B.1.2 Verifying Your Installation"}),"\n",(0,t.jsx)(n.p,{children:"After installation, verify that all components are correctly installed:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Check ROS 2 installation\nros2 doctor --report\n\n# Verify Gazebo loads correctly\ngazebo --version\n\n# Test ROS-Gazebo integration\nros2 launch gazebo_ros gazebo.launch.py world:=/usr/share/gazebo-11/worlds/empty.world\n"})}),"\n",(0,t.jsx)(n.admonition,{title:"Common Verification Steps",type:"tip",children:(0,t.jsxs)(n.p,{children:["If ",(0,t.jsx)(n.code,{children:"ros2 doctor"})," reports missing dependencies, run ",(0,t.jsx)(n.code,{children:"rosdep update"})," and restart your terminal session. For Gazebo-specific issues, ensure the ",(0,t.jsx)(n.code,{children:"GAZEBO_MODEL_PATH"})," and ",(0,t.jsx)(n.code,{children:"GAZEBO_PLUGIN_PATH"})," environment variables are set correctly."]})}),"\n",(0,t.jsx)(n.h3,{id:"b13-creating-a-humanoid-simulation-workspace",children:"B.1.3 Creating a Humanoid Simulation Workspace"}),"\n",(0,t.jsx)(n.p,{children:"Set up a dedicated workspace for humanoid robotics simulation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'# Create workspace directory\nmkdir -p ~/humanoid_ws/src\ncd ~/humanoid_ws\n\n# Initialize workspace\ncolcon build --symlink-install\n\n# Source the workspace\necho "source ~/humanoid_ws/install/setup.bash" >> ~/.bashrc\nsource ~/.bashrc\n'})}),"\n",(0,t.jsx)(n.h3,{id:"b14-troubleshooting-common-issues",children:"B.1.4 Troubleshooting Common Issues"}),"\n",(0,t.jsx)(n.p,{children:"The following table addresses frequently encountered Gazebo simulation problems:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Issue"}),(0,t.jsx)(n.th,{children:"Cause"}),(0,t.jsx)(n.th,{children:"Solution"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Black screen in Gazebo"}),(0,t.jsx)(n.td,{children:"GPU/driver incompatibility"}),(0,t.jsxs)(n.td,{children:["Install NVIDIA drivers: ",(0,t.jsx)(n.code,{children:"sudo ubuntu-drivers install nvidia"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Models not loading"}),(0,t.jsx)(n.td,{children:"Missing model files"}),(0,t.jsxs)(n.td,{children:["Check ",(0,t.jsx)(n.code,{children:"GAZEBO_MODEL_PATH"})," environment variable"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Joint controllers not responding"}),(0,t.jsx)(n.td,{children:"Controller manager not started"}),(0,t.jsxs)(n.td,{children:["Ensure ",(0,t.jsx)(n.code,{children:"controller_manager"})," is launched"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Physics unstable"}),(0,t.jsx)(n.td,{children:"Default physics settings"}),(0,t.jsxs)(n.td,{children:["Adjust ",(0,t.jsx)(n.code,{children:"sim_time"})," and physics parameters in URDF"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Slow simulation"}),(0,t.jsx)(n.td,{children:"Insufficient resources"}),(0,t.jsx)(n.td,{children:"Reduce GUI elements, use headless mode"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"For persistent physics issues, create a custom physics configuration file:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'\x3c!-- ~/.gazebo/physics.config --\x3e\n<sdf version="1.6">\n  <world name="default">\n    <physics name="default_physics" type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <gravity>0 0 -9.81</gravity>\n      <ode>\n        <solver>\n          <type>quick</type>\n          <iters>100</iters>\n          <sor>1.0</sor>\n        </solver>\n      </ode>\n    </physics>\n  </world>\n</sdf>\n'})}),"\n",(0,t.jsx)(n.h2,{id:"b2-nvidia-isaac-sim-setup",children:"B.2 NVIDIA Isaac Sim Setup"}),"\n",(0,t.jsx)(n.p,{children:"NVIDIA Isaac Sim is a powerful robotics simulation platform built on NVIDIA Omniverse. It offers photorealistic rendering, physics simulation, and seamless integration with ROS/ROS 2 for high-fidelity humanoid robotics development."}),"\n",(0,t.jsx)(n.h3,{id:"b21-system-requirements",children:"B.2.1 System Requirements"}),"\n",(0,t.jsx)(n.p,{children:"Ensure your system meets these requirements before installation:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Component"}),(0,t.jsx)(n.th,{children:"Minimum"}),(0,t.jsx)(n.th,{children:"Recommended"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"CPU"}),(0,t.jsx)(n.td,{children:"Intel Core i7-12700"}),(0,t.jsx)(n.td,{children:"Intel Core i9-13900K"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"RAM"}),(0,t.jsx)(n.td,{children:"16 GB"}),(0,t.jsx)(n.td,{children:"64 GB"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"GPU"}),(0,t.jsx)(n.td,{children:"NVIDIA RTX 3060 (8GB)"}),(0,t.jsx)(n.td,{children:"NVIDIA RTX 4090 (24GB)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"CUDA"}),(0,t.jsx)(n.td,{children:"12.0"}),(0,t.jsx)(n.td,{children:"12.2+"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Storage"}),(0,t.jsx)(n.td,{children:"50 GB SSD"}),(0,t.jsx)(n.td,{children:"100+ GB NVMe SSD"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"OS"}),(0,t.jsx)(n.td,{children:"Ubuntu 22.04 LTS"}),(0,t.jsx)(n.td,{children:"Ubuntu 22.04 LTS"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"b22-installation-steps",children:"B.2.2 Installation Steps"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'# Install NVIDIA driver (if not already installed)\nsudo ubuntu-drivers install nvidia-driver-535\nsudo reboot\n\n# Verify CUDA installation\nnvidia-smi\nnvcc --version\n\n# Install Python dependencies\nsudo apt install -y python3-pip python3-venv\n\n# Create Isaac Sim directory\nmkdir -p ~/isaac-sim\ncd ~/isaac-sim\n\n# Download Isaac Sim from NVIDIA NGC\n# Visit https://developer.nvidia.com/isaac-sim to download the latest release\n# Extract the downloaded file\ntar -xf Isaac-Sim-Release-4.0.0.tar.xz\n\n# Install Python dependencies in isolated environment\npython3 -m venv venv\nsource venv/bin/activate\npip install --upgrade pip\npip install -r ./exts/omni.isaac.sim/requirements.txt\n\n# Set up environment variables\necho "export ISAAC_SIM_PATH=$HOME/isaac-sim" >> ~/.bashrc\necho "export OMNI_KIT_BUNDLE_PATH=$ISAAC_SIM_PATH/bundle" >> ~/.bashrc\necho "export CARB_APP_PATH=$ISAAC_SIM_PATH/bundle" >> ~/.bashrc\necho "source $ISAAC_SIM_PATH/setup_boost_env.sh" >> ~/.bashrc\n\nsource ~/.bashrc\n'})}),"\n",(0,t.jsx)(n.h3,{id:"b23-licensing-information",children:"B.2.3 Licensing Information"}),"\n",(0,t.jsx)(n.p,{children:"Isaac Sim requires an NVIDIA account and accepts licensing through the following options:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"License Type"}),(0,t.jsx)(n.th,{children:"Cost"}),(0,t.jsx)(n.th,{children:"Features"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Evaluation"}),(0,t.jsx)(n.td,{children:"Free (30 days)"}),(0,t.jsx)(n.td,{children:"Full feature access"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Academic"}),(0,t.jsx)(n.td,{children:"Free (with .edu email)"}),(0,t.jsx)(n.td,{children:"Full features for research"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Commercial"}),(0,t.jsx)(n.td,{children:"Subscription-based"}),(0,t.jsx)(n.td,{children:"Full commercial features"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:["Register at ",(0,t.jsx)(n.a,{href:"https://ngc.nvidia.com/",children:"NVIDIA NGC"})," and follow the licensing instructions provided with your downloaded Isaac Sim package."]}),"\n",(0,t.jsx)(n.h3,{id:"b24-getting-started-workflow",children:"B.2.4 Getting Started Workflow"}),"\n",(0,t.jsx)(n.p,{children:"Create a basic Isaac Sim script for humanoid simulation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nBasic Isaac Sim humanoid simulation setup\nSave as: ~/isaac-sim/workspace/humanoid_basic.py\n"""\n\nimport omni.isaac.core\nimport omni.isaac.nucleus as nucleus\nfrom pxr import Usd, UsdGeom, Gf, Sdf\n\n# Initialize simulation\nomni.isaac.core.set_default_backend("omni.isaac.core")\n\n# Create a new stage\nstage = omni.usd.get_context().get_stage()\n\n# Add ground plane\nground_path = "/World/GroundPlane"\nUsdGeom.Plane.Define(stage, ground_path)\nground_prim = stage.GetPrimAtPath(ground_path)\n\n# Add lighting\nlight_path = "/World/DistantLight"\ndistant_light = UsdLux.DistantLight.Define(stage, light_path)\ndistant_light.CreateIntensityAttr(1000)\ndistant_light.CreateAngleAttr(0.53)\n\n# Configure physics\nscene_path = "/World"\nscene = UsdPhysics.Scene.Define(stage, scene_path)\nscene.CreateGravityDirectionAttr(Gf.Vec3f(0, 0, -1))\nscene.CreateGravityMagnitudeAttr(9.81)\n\nprint("Isaac Sim humanoid workspace initialized successfully")\n'})}),"\n",(0,t.jsx)(n.p,{children:"Launch Isaac Sim with your custom script:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"cd ~/isaac-sim\n./isaac-sim.sh --no-window --script ./workspace/humanoid_basic.py\n"})}),"\n",(0,t.jsx)(n.h3,{id:"b25-ros-2-integration-with-isaac-sim",children:"B.2.5 ROS 2 Integration with Isaac Sim"}),"\n",(0,t.jsx)(n.p,{children:"Enable ROS 2 communication from Isaac Sim:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Install ROS 2 bridge\ncd ~/isaac-sim\n./isaac-sim.sh --exts ext/omni.isaac.ros2_bridge\n\n# Create a ROS 2 enabled launch script\ncat > ~/isaac-sim/workspace/ros2_humanoid.launch.py << 'EOF'\n\"\"\"ROS 2 enabled humanoid simulation launch script\"\"\"\nimport launch\nfrom launch_ros.actions import ComposableNodeContainer\nfrom launch_ros.descriptions import ComposableNode\n\ndef generate_launch_description():\n    container = ComposableNodeContainer(\n        name='isaac_sim_container',\n        namespace='/isaac_sim',\n        package='rclcpp_components',\n        executable='component_container',\n        composable_node_descriptions=[\n            ComposableNode(\n                name='robot_state_publisher',\n                package='robot_state_publisher',\n                executable='robot_state_publisher',\n                parameters=[{'robot_description': '/path/to/robot.urdf'}]\n            ),\n            ComposableNode(\n                name='joint_state_publisher',\n                package='joint_state_publisher',\n                executable='joint_state_publisher'\n            )\n        ],\n        output='screen'\n    )\n    return launch.LaunchDescription([container])\n\nif __name__ == '__main__':\n    generate_launch_description()\nEOF\n"})}),"\n",(0,t.jsx)(n.h2,{id:"b3-unity-for-robotics",children:"B.3 Unity for Robotics"}),"\n",(0,t.jsx)(n.p,{children:"Unity provides a flexible environment for robotics simulation with its high-fidelity physics engine and extensive asset ecosystem. The Unity Robotics Hub offers specialized packages for robot simulation and ROS integration."}),"\n",(0,t.jsx)(n.h3,{id:"b31-unity-installation",children:"B.3.1 Unity Installation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Install Unity Hub\nwget -q https://public-cdn.cloud.unity3d.com/hub/prod/UnityHubSetup.deb\nsudo dpkg -i UnityHubSetup.deb\nsudo apt-get install -f -y\n\n# Install Unity Editor (2022.3 LTS recommended for robotics)\n# Open Unity Hub and install Unity Editor 2022.3.20f1 or newer\n# Select the following modules during installation:\n# - Linux Build Support\n# - Windows Build Support\n# - Android Build Support\n# - iOS Build Support\n"})}),"\n",(0,t.jsx)(n.h3,{id:"b32-ros-unity-integration-setup",children:"B.3.2 ROS-Unity Integration Setup"}),"\n",(0,t.jsx)(n.p,{children:"Create a new Unity project with ROS integration:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Create project directory\nmkdir -p ~/unity-ros-projects\ncd ~/unity-ros-projects\n\n# Clone Unity Robotics Hub packages\ngit clone https://github.com/Unity-Technologies/Unity-Robotics-Hub.git\ncd Unity-Robotics-Hub\n\n# Note: Import packages through Unity Package Manager\n# Window > Package Manager > Add package from git URL\n# Add: https://github.com/Unity-Technologies/ros2-message-publisher.git\n# Add: https://github.com/Unity-Technologies/ros2-service-publisher.git\n"})}),"\n",(0,t.jsx)(n.h3,{id:"b33-basic-unity-robotics-project-setup",children:"B.3.3 Basic Unity Robotics Project Setup"}),"\n",(0,t.jsx)(n.p,{children:"Create a simple humanoid robot prefab in Unity:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// HumanoidRobotController.cs\nusing UnityEngine;\nusing Unity.Robotics.ROSTCPConnector;\nusing Unity.Robotics.ROSTCPConnector.ROSGeometry;\nusing sensor_msgs.msg;\nusing geometry_msgs.msg;\n\npublic class HumanoidRobotController : MonoBehaviour\n{\n    [Header("Joint Configuration")]\n    public ArticulationBody[] leftLegJoints;\n    public ArticulationBody[] rightLegJoints;\n    public ArticulationBody[] leftArmJoints;\n    public ArticulationBody[] rightArmJoints;\n    public ArticulationBody torsoJoint;\n\n    [Header("ROS Settings")]\n    public string cmdVelTopic = "/cmd_vel";\n    public string jointStateTopic = "/joint_states";\n\n    private ROSConnection ros;\n    private Vector3 targetVelocity;\n    private float targetYaw;\n\n    void Start()\n    {\n        ros = ROSConnection.GetOrCreateInstance();\n        ros.RegisterPublisher<geometry_msgs.msg.Twist>(cmdVelTopic);\n        ros.Subscribe<geometry_msgs.msg.Twist>(cmdVelTopic, ReceiveVelocityCommand);\n\n        InitializeJoints();\n    }\n\n    void InitializeJoints()\n    {\n        // Configure joint drive properties\n        foreach (var joint in leftLegJoints)\n        {\n            joint.xDrive = new ArticulationDrive\n            {\n                stiffness = 1000f,\n                damping = 100f,\n                forceLimit = 500f\n            };\n        }\n    }\n\n    void ReceiveVelocityCommand(Twist msg)\n    {\n        targetVelocity = msg.linear.From<FLU>();\n        targetYaw = (float)msg.angular.z;\n    }\n\n    void FixedUpdate()\n    {\n        // Apply velocity commands to joints\n        for (int i = 0; i < leftLegJoints.Length; i++)\n        {\n            float targetPosition = Mathf.Clamp(\n                targetVelocity.z * i * 0.1f,\n                leftLegJoints[i].xDrive.lowerLimit,\n                leftLegJoints[i].xDrive.upperLimit\n            );\n            leftLegJoints[i].SetTarget(TargetIndex.X, targetPosition);\n            rightLegJoints[i].SetTarget(TargetIndex.X, -targetPosition);\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"b34-unity-ros-2-communication-setup",children:"B.3.4 Unity-ROS 2 Communication Setup"}),"\n",(0,t.jsx)(n.p,{children:"Configure ROS 2 communication in Unity:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Build ROS 2 message types for Unity\ncd ~/unity-ros-projects\nmkdir -p msg_gen\ncd msg_gen\n\n# Generate C# message definitions\nros2 run ros2_message_gen generate_messages \\\n    --input-pkg your_robot_description \\\n    --output-dir ./src/GeneratedMessages\n\n# Import generated messages into Unity project\n# Copy GeneratedMessages to Assets/RosMessages/\n"})}),"\n",(0,t.jsx)(n.h2,{id:"b4-container-and-virtual-machine-setup",children:"B.4 Container and Virtual Machine Setup"}),"\n",(0,t.jsx)(n.p,{children:"Containerization ensures reproducible simulation environments across different machines and facilitates deployment of simulation workflows."}),"\n",(0,t.jsx)(n.h3,{id:"b41-docker-setup-for-simulation",children:"B.4.1 Docker Setup for Simulation"}),"\n",(0,t.jsx)(n.p,{children:"Create a Docker environment for consistent Gazebo simulation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dockerfile",children:'# Dockerfile.gazebo-sim\nFROM osrf/ros:humble-desktop-full\n\n# Install Gazebo and dependencies\nRUN apt-get update && apt-get install -y \\\n    gazebo \\\n    libgazebo11-dev \\\n    ros-humble-gazebo-ros-pkgs \\\n    ros-humble-gazebo-ros2-control \\\n    python3-pip \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Set up non-interactive installation\nENV DEBIAN_FRONTEND=noninteractive\n\n# Create user for simulation\nRUN useradd -m -s /bin/bash simuser\nUSER simuser\nWORKDIR /home/simuser\n\n# Copy workspace files\nCOPY --chown=simuser:simuser . /home/simuser/catkin_ws\nRUN /bin/bash -c "source /opt/ros/humble/setup.sh && \\\n    cd /home/simuser/catkin_ws && \\\n    colcon build --symlink-install"\n\n# Set entry point\nENTRYPOINT ["/bin/bash", "-c", "source /opt/ros/humble/setup.sh && source /home/simuser/catkin_ws/install/setup.sh && exec \\"$@\\""]\n\n# Build and run\n# docker build -f Dockerfile.gazebo-sim -t gazebo-sim .\n# docker run -it --rm \\\n#     --privileged \\\n#     --gpus all \\\n#     -e DISPLAY=$DISPLAY \\\n#     -v /tmp/.X11-unix:/tmp/.X11-unix \\\n#     gazebo-sim\n'})}),"\n",(0,t.jsx)(n.h3,{id:"b42-docker-compose-for-multi-container-simulation",children:"B.4.2 Docker Compose for Multi-Container Simulation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"# docker-compose.yml\nversion: '3.8'\n\nservices:\n  gazebo-sim:\n    build:\n      context: .\n      dockerfile: Dockerfile.gazebo-sim\n    container_name: humanoid-sim\n    privileged: true\n    gpus: all\n    environment:\n      - DISPLAY=${DISPLAY}\n      - NVIDIA_VISIBLE_DEVICES=all\n      - NVIDIA_DRIVER_CAPABILITIES=graphics,utility,compute\n    volumes:\n      - /tmp/.X11-unix:/tmp/.X11-unix:rw\n      - ./workspace:/home/simuser/workspace:rw\n    networks:\n      - sim-network\n    deploy:\n      resources:\n        reservations:\n          devices:\n            - driver: nvidia\n              count: all\n              capabilities: [gpu]\n\n  ros-bridge:\n    image: osrf/ros:humble-ros-base\n    container_name: ros-bridge\n    command: >\n      ros2 launch rosbridge_server rosbridge_websocket_launch.xml\n    networks:\n      - sim-network\n    depends_on:\n      - gazebo-sim\n\nnetworks:\n  sim-network:\n    driver: bridge\n"})}),"\n",(0,t.jsx)(n.h3,{id:"b43-nvidia-isaac-sim-container",children:"B.4.3 NVIDIA Isaac Sim Container"}),"\n",(0,t.jsx)(n.p,{children:"Run Isaac Sim in a Docker container:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dockerfile",children:'# Dockerfile.isaac-sim\nFROM nvidia/cuda:12.2-devel-ubuntu22.04\n\n# Install dependencies\nRUN apt-get update && apt-get install -y \\\n    python3.10 \\\n    python3-pip \\\n    libgl1-mesa-glx \\\n    libglib2.0-0 \\\n    libnvidia-gl-535 \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Set up Isaac Sim environment\nENV ISAAC_SIM_PATH=/isaac-sim\nENV OMNI_KIT_BUNDLE_PATH=/isaac-sim/bundle\nENV CARB_APP_PATH=/isaac-sim/bundle\n\n# Copy Isaac Sim files (mount volume in production)\nCOPY Isaac-Sim-4.0.0 /isaac-sim\n\nWORKDIR /isaac-sim\nCMD ["./isaac-sim.sh"]\n'})}),"\n",(0,t.jsx)(n.h3,{id:"b44-virtual-machine-recommendations",children:"B.4.4 Virtual Machine Recommendations"}),"\n",(0,t.jsx)(n.p,{children:"For users requiring complete system isolation, the following VM configurations are recommended:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Use Case"}),(0,t.jsx)(n.th,{children:"Provider"}),(0,t.jsx)(n.th,{children:"Recommended Config"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Development"}),(0,t.jsx)(n.td,{children:"VirtualBox"}),(0,t.jsx)(n.td,{children:"8 CPU, 32GB RAM, 100GB disk"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"CI/CD"}),(0,t.jsx)(n.td,{children:"Vagrant + VirtualBox"}),(0,t.jsx)(n.td,{children:"4 CPU, 16GB RAM, 60GB disk"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Cloud"}),(0,t.jsx)(n.td,{children:"AWS EC2 (g4dn.xlarge)"}),(0,t.jsx)(n.td,{children:"GPU instance for rendering"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"High-Performance"}),(0,t.jsx)(n.td,{children:"VMware ESXi"}),(0,t.jsx)(n.td,{children:"Passthrough GPU recommended"})]})]})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'# Vagrantfile for simulation VM\nVagrant.configure("2") do |config|\n  config.vm.box = "generic/ubuntu2204"\n  config.vm.provider "virtualbox" do |vb|\n    vb.memory = "32768"\n    vb.cpus = "8"\n    vb.graphics_controller = "vmsvga"\n    vb.video_memory = "128"\n  end\n  config.vm.provision "shell", inline: <<-SHELL\n    apt-get update\n    apt-get install -y ros-humble-desktop-full gazebo\n    SHELL\nend\n'})}),"\n",(0,t.jsx)(n.h2,{id:"b5-performance-optimization",children:"B.5 Performance Optimization"}),"\n",(0,t.jsx)(n.p,{children:"Optimizing simulation performance is critical for real-time humanoid robotics development. The following techniques maximize simulation speed and accuracy."}),"\n",(0,t.jsx)(n.h3,{id:"b51-gpu-optimization",children:"B.5.1 GPU Optimization"}),"\n",(0,t.jsx)(n.p,{children:"Maximize GPU utilization for accelerated physics and rendering:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Verify GPU is available for simulation\nnvidia-smi\n\n# Check CUDA version compatibility\nnvcc --version\n\n# Monitor GPU usage during simulation\nwatch -n 1 nvidia-smi\n"})}),"\n",(0,t.jsx)(n.p,{children:"Configure Isaac Sim for optimal GPU performance:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Optimized Isaac Sim settings\nimport omni.kit.settings\n\n# Enable RTX rendering\nomni.kit.settings.get_settings().set_bool("/rtx/enabled", True)\nomni.kit.settings.get_settings().set_bool("/rtx/directLighting/enabled", True)\n\n# Configure DLSS for performance\nomni.kit.settings.get_settings().set_bool("/rtx/dlsr/enabled", True)\nomni.kit.settings.get_settings().set_int("/rtx/dlsr/width", 1280)\nomni.kit.settings.get_settings().set_int("/rtx/dlsr/height", 720)\n\n# Optimize physics settings\nomni.kit.settings.get_settings().set_int("/physics/maxSolverIterations", 64)\nomni.kit.settings.get_settings().set_float("/physics/solverTolerance", 1e-4)\n'})}),"\n",(0,t.jsx)(n.h3,{id:"b52-memory-management",children:"B.5.2 Memory Management"}),"\n",(0,t.jsx)(n.p,{children:"Handle large-scale humanoid simulations efficiently:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Memory-optimized simulation script\nimport gc\nimport omni.usd\nfrom pxr import Usd, UsdGeom\n\nclass OptimizedSimulation:\n    def __init__(self, stage_url):\n        self.stage = omni.usd.get_context().open_stage(stage_url)\n        self.cache_size = 100  # Limit cached prims\n        self.prim_cache = []\n\n    def load_robot_safely(self, robot_usd_path):\n        """Load robot with memory-conscious approach"""\n        # Clear old cache\n        self.clear_cache()\n        gc.collect()\n\n        # Load stage in parts to reduce peak memory\n        stage = omni.usd.get_context().open_stage(robot_usd_path)\n\n        # Process in batches\n        batch_size = 50\n        all_prims = [p for p in stage.Traverse()\n                    if p.GetTypeName() in ["Xform", "Mesh"]]\n\n        for i in range(0, len(all_prims), batch_size):\n            batch = all_prims[i:i + batch_size]\n            self.process_batch(batch)\n\n        return stage\n\n    def clear_cache(self):\n        """Clear cached prims to free memory"""\n        self.prim_cache.clear()\n        gc.collect()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.clear_cache()\n        omni.usd.get_context().close_stage()\n'})}),"\n",(0,t.jsx)(n.h3,{id:"b53-simulation-speed-optimization",children:"B.5.3 Simulation Speed Optimization"}),"\n",(0,t.jsx)(n.p,{children:"Balance simulation speed and accuracy with these techniques:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'# Gazebo physics optimization (world.sdf)\n<sdf version="1.10">\n  <world name="optimized_world">\n    <physics name="fast_physics" type="dart">\n      <max_step_size>0.002</max_step_size>\n      <real_time_factor>2.0</real_time_factor>\n      <real_time_update_rate>120</real_time_update_rate>\n      <gravity>0 0 -9.81</gravity>\n    </physics>\n\n    \x3c!-- Simplified collision for humanoid --\x3e\n    <model name="humanoid">\n      <link name="torso">\n        <collision>\n          <geometry>\n            <box>\n              <size>0.3 0.4 0.5</size>\n            </box>\n          </geometry>\n          <max_contacts>4</max_contacts>\n        </collision>\n      </link>\n    </model>\n  </world>\n</sdf>\n'})}),"\n",(0,t.jsx)(n.p,{children:"Use headless mode for training scenarios:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Run Gazebo in headless mode\ngzserver --headless worlds/humanoid.world\n\n# Run Isaac Sim without UI\n./isaac-sim.sh --no-window --num-frames 1000\n\n# Unity headless build\n./Unity -batchmode -nographics -quit -projectPath /path/to/project\n"})}),"\n",(0,t.jsx)(n.h3,{id:"b54-multi-node-distributed-simulation",children:"B.5.4 Multi-Node Distributed Simulation"}),"\n",(0,t.jsx)(n.p,{children:"Scale simulation across multiple machines for complex scenarios:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Master node setup\nexport ROS_MASTER_URI=http://master:11311\nexport ROS_HOSTNAME=master.local\n\n# Worker node setup\nexport ROS_MASTER_URI=http://master:11311\nexport ROS_HOSTNAME=worker1.local\n\n# Launch distributed Gazebo\n# On master node:\nroslaunch gazebo_ros multi_robot_name:=true world_name:=humanoid.world\n\n# On worker nodes:\nroslaunch gazebo_ros worker_node.launch\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Distributed simulation manager\nclass DistributedSimManager:\n    def __init__(self, master_uri, worker_nodes):\n        self.master_uri = master_uri\n        self.worker_nodes = worker_nodes\n        self.allocations = {}\n\n    def allocate_humanoid_parts(self):\n        """Distribute humanoid components across nodes"""\n        parts = {\n            "left_leg": "worker1",\n            "right_leg": "worker2",\n            "torso": "master",\n            "left_arm": "worker3",\n            "right_arm": "worker4",\n            "head": "master"\n        }\n\n        for part, node in parts.items():\n            self.allocations[part] = {\n                "node": node,\n                "status": "allocated"\n            }\n\n        return self.allocations\n\n    def synchronize_simulation(self):\n        """Ensure simulation state is synchronized"""\n        import rospy\n        from std_msgs.msg import Float64MultiArray\n\n        pub = rospy.Publisher(\'/sync/timestamp\', Float64MultiArray, queue_size=10)\n        rate = rospy.Rate(100)  # 100 Hz sync\n\n        while not rospy.is_shutdown():\n            msg = Float64MultiArray()\n            msg.data = [rospy.get_time()]\n            pub.publish(msg)\n            rate.sleep()\n'})}),"\n",(0,t.jsx)(n.h3,{id:"b55-performance-monitoring-tools",children:"B.5.5 Performance Monitoring Tools"}),"\n",(0,t.jsx)(n.p,{children:"Implement comprehensive performance monitoring:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nSimulation Performance Monitor\nUsage: python perf_monitor.py\n"""\n\nimport time\nimport psutil\nimport GPUtil\nfrom datetime import datetime\n\nclass SimulationMonitor:\n    def __init__(self, log_interval=1.0):\n        self.log_interval = log_interval\n        self.metrics = {\n            "cpu_percent": [],\n            "memory_percent": [],\n            "gpu_load": [],\n            "gpu_memory": [],\n            "timestamps": []\n        }\n\n    def get_cpu_usage(self):\n        return psutil.cpu_percent(interval=None)\n\n    def get_memory_usage(self):\n        return psutil.virtual_memory().percent\n\n    def get_gpu_usage(self):\n        gpus = GPUtil.getGPUs()\n        if gpus:\n            return gpus[0].load * 100\n        return 0.0\n\n    def get_gpu_memory(self):\n        gpus = GPUtil.getGPUs()\n        if gpus:\n            return (gpus[0].memoryUsed / gpus[0].memoryTotal) * 100\n        return 0.0\n\n    def collect_metrics(self):\n        """Collect all performance metrics"""\n        timestamp = datetime.now().isoformat()\n        self.metrics["timestamps"].append(timestamp)\n        self.metrics["cpu_percent"].append(self.get_cpu_usage())\n        self.metrics["memory_percent"].append(self.get_memory_usage())\n        self.metrics["gpu_load"].append(self.get_gpu_usage())\n        self.metrics["gpu_memory"].append(self.get_gpu_memory())\n\n    def generate_report(self):\n        """Generate performance report"""\n        report = {\n            "cpu_avg": sum(self.metrics["cpu_percent"]) / len(self.metrics["cpu_percent"]),\n            "memory_avg": sum(self.metrics["memory_percent"]) / len(self.metrics["memory_percent"]),\n            "gpu_load_avg": sum(self.metrics["gpu_load"]) / len(self.metrics["gpu_load"]),\n            "gpu_memory_avg": sum(self.metrics["gpu_memory"]) / len(self.metrics["gpu_memory"]),\n            "samples": len(self.metrics["timestamps"])\n        }\n        return report\n\n    def print_status(self):\n        """Print current system status"""\n        print(f"[{datetime.now().strftime(\'%H:%M:%S\')}] "\n              f"CPU: {self.get_cpu_usage():.1f}% | "\n              f"RAM: {self.get_memory_usage():.1f}% | "\n              f"GPU: {self.get_gpu_usage():.1f}% | "\n              f"VRAM: {self.get_gpu_memory():.1f}%")\n\nif __name__ == "__main__":\n    monitor = SimulationMonitor()\n    try:\n        while True:\n            monitor.print_status()\n            monitor.collect_metrics()\n            time.sleep(monitor.log_interval)\n    except KeyboardInterrupt:\n        report = monitor.generate_report()\n        print("\\n=== Performance Report ===")\n        for key, value in report.items():\n            print(f"{key}: {value:.2f}")\n'})}),"\n",(0,t.jsx)(n.h2,{id:"b6-summary",children:"B.6 Summary"}),"\n",(0,t.jsx)(n.p,{children:"This appendix has provided comprehensive setup instructions for the primary simulation platforms used in humanoid robotics development. The key takeaways are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Gazebo"})," offers the best integration with ROS 2 and is ideal for algorithm development and testing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"NVIDIA Isaac Sim"})," provides photorealistic rendering and high-fidelity physics for perception research"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unity"})," enables rapid prototyping with its extensive asset ecosystem and C# scripting"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Containerization"})," ensures reproducibility and simplifies deployment across different environments"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance optimization"})," is essential for real-time simulation, particularly for learning-based approaches"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"With these simulation environments properly configured, you can proceed to implement the humanoid robotics algorithms described in the subsequent chapters, testing them in simulation before deployment to physical hardware."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Next Steps:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Verify all installations by running the verification commands in each section"}),"\n",(0,t.jsx)(n.li,{children:"Set up your preferred simulation environment for the specific chapters you plan to work through"}),"\n",(0,t.jsx)(n.li,{children:"Review the performance monitoring tools to establish baseline metrics for your system"}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(6540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);